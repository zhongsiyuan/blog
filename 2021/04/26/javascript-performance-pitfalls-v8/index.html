<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>V8 中的 JavaScript 性能陷阱 - SiYuanPublic</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="SiYuanPublic"><meta name="msapplication-TileImage" content="/images/favicon.ico"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="SiYuanPublic"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="近年来，JavaScript引擎在各个方面都有所改进。JavaScript的性能已经达到了可以轻松与传统上被认为更适合高性能计算的编程语言竞争的水平。这不仅适用于V8，Chrome和Linux内部的JavaScript引擎Node.js，并且适用于几乎所有主要的JavaScript引擎，包括ChakraCore，Edge的内部的引擎，JavaScriptCore，Safari内部的引擎，以及Spi"><meta property="og:type" content="blog"><meta property="og:title" content="V8 中的 JavaScript 性能陷阱"><meta property="og:url" content="http://example.com/2021/04/26/javascript-performance-pitfalls-v8/"><meta property="og:site_name" content="SiYuanPublic"><meta property="og:description" content="近年来，JavaScript引擎在各个方面都有所改进。JavaScript的性能已经达到了可以轻松与传统上被认为更适合高性能计算的编程语言竞争的水平。这不仅适用于V8，Chrome和Linux内部的JavaScript引擎Node.js，并且适用于几乎所有主要的JavaScript引擎，包括ChakraCore，Edge的内部的引擎，JavaScriptCore，Safari内部的引擎，以及Spi"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/images/javascript-performance-pitfalls-v8/v8_memory_address.svg"><meta property="og:image" content="http://example.com/images/javascript-performance-pitfalls-v8/object.svg"><meta property="og:image" content="http://example.com/images/javascript-performance-pitfalls-v8/heap_number.svg"><meta property="og:image" content="http://example.com/images/javascript-performance-pitfalls-v8/heap_number_example.svg"><meta property="og:image" content="http://example.com/images/javascript-performance-pitfalls-v8/heap_number_example_2.svg"><meta property="og:image" content="http://example.com/images/javascript-performance-pitfalls-v8/lattice.svg"><meta property="og:image" content="http://example.com/images/javascript-performance-pitfalls-v8/double_shape.svg"><meta property="og:image" content="http://example.com/images/javascript-performance-pitfalls-v8/shape_sub_tree.svg"><meta property="og:image" content="http://example.com/images/javascript-performance-pitfalls-v8/double_field.svg"><meta property="article:published_time" content="2021-04-25T16:42:28.000Z"><meta property="article:modified_time" content="2021-05-31T14:07:40.675Z"><meta property="article:author" content="SiYuan Zhong"><meta property="article:tag" content="v8 engine optimization"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/images/javascript-performance-pitfalls-v8/v8_memory_address.svg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2021/04/26/javascript-performance-pitfalls-v8/"},"headline":"SiYuanPublic","image":[],"datePublished":"2021-04-25T16:42:28.000Z","dateModified":"2021-05-31T14:07:40.675Z","author":{"@type":"Person","name":"SiYuan Zhong"},"description":"近年来，JavaScript引擎在各个方面都有所改进。JavaScript的性能已经达到了可以轻松与传统上被认为更适合高性能计算的编程语言竞争的水平。这不仅适用于V8，Chrome和Linux内部的JavaScript引擎Node.js，并且适用于几乎所有主要的JavaScript引擎，包括ChakraCore，Edge的内部的引擎，JavaScriptCore，Safari内部的引擎，以及Spi"}</script><link rel="canonical" href="http://example.com/2021/04/26/javascript-performance-pitfalls-v8/"><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/brand.png" alt="SiYuanPublic" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="GitHub" href="https://github.com/zhongsiyuan"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-25T16:42:28.000Z" title="2021-04-25T16:42:28.000Z">2021-04-26</time>发表</span><span class="level-item"><time dateTime="2021-05-31T14:07:40.675Z" title="2021-05-31T14:07:40.675Z">2021-05-31</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/JavaScriptBasic/">JavaScriptBasic</a></span><span class="level-item">43 分钟读完 (大约6419个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">V8 中的 JavaScript 性能陷阱</h1><div class="content"><p>近年来，JavaScript引擎在各个方面都有所改进。JavaScript的性能已经达到了可以轻松与传统上被认为更适合高性能计算的编程语言竞争的水平。这不仅适用于V8，Chrome和Linux内部的JavaScript引擎Node.js，并且适用于几乎所有主要的JavaScript引擎，包括ChakraCore，Edge的内部的引擎，JavaScriptCore，Safari内部的引擎，以及SpiderMonkey，Firefox内部的引擎。</p>
<a id="more"></a>

<p>不仅峰值性能得到了改善，而且引擎还实现了更一致和可预测的性能水平。鉴于JavaScript是一种高度动态的语言，所有这些性能都基于在引擎中选择正确的启发式算法。JavaScript引擎使用预测优化和内联缓存等技术来加速执行可能的途径。</p>
<p>但是启发式算法也可以很容易对产生您不利，这将帮助您了解他们。所以今天我将分享一些关于v8引擎中两个微妙性能缺陷的背景知识。意识到这些潜在的陷阱可能会帮助您解决问题，如果您更容易踩到这些陷阱的话。</p>
<h2 id="优化限制"><a href="#优化限制" class="headerlink" title="优化限制"></a>优化限制</h2><p>V8中内置的编译器（TurboFan优化编译器和Ignition节码生成器）是被称为JIT的方法。这意味着编译单位始终是一种方法，也就是JavaScript中的函数。当优化编译器发现热调用站点并通过这样做（通常称为内联）进一步优化的潜力时，它能够包括其他方法的主体。与此相比，使用所谓的跟踪 JIT的其他运行时间 - LuaJIT和PyPy是这里比较流行的示例，其中优化的单位是以前重复执行的连续字节码的任意序列。</p>
<p>在方法JIT和跟踪JIT中，优化器可以处理的输入大小总是有一个上限。对于方法JIT，这个限制自然由函数本身的大小定义。TurboFan也有这样一个限制，目前是60KB字节码（在runtime-profiler.cc中的kMaxBytecodeSizeForOpt常量）-profiler.cc). 也就是说，如果您的函数生成的字节码大于60KB，它们将永远不会被TurboFan优化，即使它们被认为是热的（即经常调用）。</p>
<p>让我们思考一个例子，使用eval动态生成函数(我们故意不在这里使用函数构造器，因为这不允许我们在JavaScript引擎语法上对可以识别的函数的上加上一个名称，这将使研究变得非常具有挑战性）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generate</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> s = <span class="string">&quot;(function add&quot;</span> + n + <span class="string">&quot;(x) &#123; return 0&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    s += <span class="string">&quot;+x&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  s += <span class="string">&quot;; &#125;)&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">eval</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个generate函数构造了一个新的JavaScript函数对象，将传递给它的参数相加n次。因此，当您调用generate(10)时，您将得到一个如下所示的函数对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add10</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>+x+x+x+x+x+x+x+x+x+x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在让我们以上面的一个具体例子来将它运行在NodeJS中:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add10.js</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generate</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> s = <span class="string">&quot;(function add&quot;</span> + n + <span class="string">&quot;(x) &#123; return 0&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    s += <span class="string">&quot;+x&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  s += <span class="string">&quot;; &#125;)&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">eval</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add10 = generate(<span class="number">10</span>);</span><br><span class="line">add10();</span><br></pre></td></tr></table></figure>
<p>查看add10函数生成的字节码，在node shell中使用–print bytecode命令，我们看到如下内容（输出来自NodeJS v10.15）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">$ node --print-bytecode add10.js</span><br><span class="line">…</span><br><span class="line">[generated bytecode for function: add10]</span><br><span class="line">Parameter count 2</span><br><span class="line">Frame size 8</span><br><span class="line">   19 E&gt; 0x279c523204b2 @    0 : a5                StackCheck</span><br><span class="line">   26 S&gt; 0x279c523204b3 @    1 : 0b                LdaZero</span><br><span class="line">         0x279c523204b4 @    2 : 26 fb             Star r0</span><br><span class="line">         0x279c523204b6 @    4 : 25 02             Ldar a0</span><br><span class="line">   34 E&gt; 0x279c523204b8 @    6 : 34 fb 00          Add r0, [0]</span><br><span class="line">         0x279c523204bb @    9 : 26 fb             Star r0</span><br><span class="line">         0x279c523204bd @   11 : 25 02             Ldar a0</span><br><span class="line">   36 E&gt; 0x279c523204bf @   13 : 34 fb 01          Add r0, [1]</span><br><span class="line">         0x279c523204c2 @   16 : 26 fb             Star r0</span><br><span class="line">         0x279c523204c4 @   18 : 25 02             Ldar a0</span><br><span class="line">   38 E&gt; 0x279c523204c6 @   20 : 34 fb 02          Add r0, [2]</span><br><span class="line">         0x279c523204c9 @   23 : 26 fb             Star r0</span><br><span class="line">         0x279c523204cb @   25 : 25 02             Ldar a0</span><br><span class="line">   40 E&gt; 0x279c523204cd @   27 : 34 fb 03          Add r0, [3]</span><br><span class="line">         0x279c523204d0 @   30 : 26 fb             Star r0</span><br><span class="line">         0x279c523204d2 @   32 : 25 02             Ldar a0</span><br><span class="line">   42 E&gt; 0x279c523204d4 @   34 : 34 fb 04          Add r0, [4]</span><br><span class="line">         0x279c523204d7 @   37 : 26 fb             Star r0</span><br><span class="line">         0x279c523204d9 @   39 : 25 02             Ldar a0</span><br><span class="line">   44 E&gt; 0x279c523204db @   41 : 34 fb 05          Add r0, [5]</span><br><span class="line">         0x279c523204de @   44 : 26 fb             Star r0</span><br><span class="line">         0x279c523204e0 @   46 : 25 02             Ldar a0</span><br><span class="line">   46 E&gt; 0x279c523204e2 @   48 : 34 fb 06          Add r0, [6]</span><br><span class="line">         0x279c523204e5 @   51 : 26 fb             Star r0</span><br><span class="line">         0x279c523204e7 @   53 : 25 02             Ldar a0</span><br><span class="line">   48 E&gt; 0x279c523204e9 @   55 : 34 fb 07          Add r0, [7]</span><br><span class="line">         0x279c523204ec @   58 : 26 fb             Star r0</span><br><span class="line">         0x279c523204ee @   60 : 25 02             Ldar a0</span><br><span class="line">   50 E&gt; 0x279c523204f0 @   62 : 34 fb 08          Add r0, [8]</span><br><span class="line">         0x279c523204f3 @   65 : 26 fb             Star r0</span><br><span class="line">         0x279c523204f5 @   67 : 25 02             Ldar a0</span><br><span class="line">   52 E&gt; 0x279c523204f7 @   69 : 34 fb 09          Add r0, [9]</span><br><span class="line">   55 S&gt; 0x279c523204fa @   72 : a9                Return</span><br><span class="line">Constant pool (size &#x3D; 0)</span><br><span class="line">Handler Table (size &#x3D; 0)</span><br><span class="line">…</span><br></pre></td></tr></table></figure>
<p>由于NodeJS运行了很多自己的JavaScript，您可能会在这里获得输出页面。搜索短语[generated bytecode for function: add10]，其中下面的字节码转储包含10个加法序列，中间包含Star字节码和Ldar字节码。</p>
<p>除去不相关的部分，我们可以看到具体的字节码输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> 0 : a5                StackCheck</span><br><span class="line"> 1 : 0b                LdaZero</span><br><span class="line"> 2 : 26 fb             Star r0</span><br><span class="line"> 4 : 25 02             Ldar a0</span><br><span class="line"> 6 : 34 fb 00          Add r0, [0]</span><br><span class="line"> 9 : 26 fb             Star r0</span><br><span class="line">11 : 25 02             Ldar a0</span><br><span class="line">13 : 34 fb 01          Add r0, [1]</span><br><span class="line">16 : 26 fb             Star r0</span><br><span class="line">18 : 25 02             Ldar a0</span><br><span class="line">20 : 34 fb 02          Add r0, [2]</span><br><span class="line">23 : 26 fb             Star r0</span><br><span class="line">25 : 25 02             Ldar a0</span><br><span class="line">27 : 34 fb 03          Add r0, [3]</span><br><span class="line">30 : 26 fb             Star r0</span><br><span class="line">32 : 25 02             Ldar a0</span><br><span class="line">34 : 34 fb 04          Add r0, [4]</span><br><span class="line">37 : 26 fb             Star r0</span><br><span class="line">39 : 25 02             Ldar a0</span><br><span class="line">41 : 34 fb 05          Add r0, [5]</span><br><span class="line">44 : 26 fb             Star r0</span><br><span class="line">46 : 25 02             Ldar a0</span><br><span class="line">48 : 34 fb 06          Add r0, [6]</span><br><span class="line">51 : 26 fb             Star r0</span><br><span class="line">53 : 25 02             Ldar a0</span><br><span class="line">55 : 34 fb 07          Add r0, [7]</span><br><span class="line">58 : 26 fb             Star r0</span><br><span class="line">60 : 25 02             Ldar a0</span><br><span class="line">62 : 34 fb 08          Add r0, [8]</span><br><span class="line">65 : 26 fb             Star r0</span><br><span class="line">67 : 25 02             Ldar a0</span><br><span class="line">69 : 34 fb 09          Add r0, [9]</span><br><span class="line">72 : a9                Return</span><br></pre></td></tr></table></figure>
<p>查看上面的输出，我们看到生成的字节代码为 73 字节大小（72 是字节代码的偏移，该指令的大小为 1 字节）。考虑到我们之前了解到关于TurboFan的60KB极限的情况，这个功能应该可以被TurboFan轻松优化。让我们试着看看如果我们把这个函数放到一个热循环中会发生什么。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add10-optimized.js</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generate</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> s = <span class="string">&quot;(function add&quot;</span> + n + <span class="string">&quot;(x) &#123; return 0&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    s += <span class="string">&quot;+x&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  s += <span class="string">&quot;; &#125;)&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">eval</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add10 = generate(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span> * <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">  result += add10(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在NodeJS内部运行此代码段，并传递–trace opt命令行参数，我们会看到类似于以下输出的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ node --trace-opt add10-optimized.js</span><br><span class="line">[marking 0x32fc83347751 &lt;JSFunction add10 (sfi &#x3D; 0x32fcde157b91)&gt; for optimized recompilation, reason: small function, ICs with typeinfo: 10&#x2F;10 (100%), generic ICs: 0&#x2F;10 (0%)]</span><br><span class="line">[compiling method 0x32fc83347751 &lt;JSFunction add10 (sfi &#x3D; 0x32fcde157b91)&gt; using TurboFan]</span><br><span class="line">[optimizing 0x32fc83347751 &lt;JSFunction add10 (sfi &#x3D; 0x32fcde157b91)&gt; - took 0.823, 0.514, 0.016 ms]</span><br><span class="line">[completed optimizing 0x32fc83347751 &lt;JSFunction add10 (sfi &#x3D; 0x32fcde157b91)&gt;]</span><br></pre></td></tr></table></figure>
<p>您可能会看到关于其他正在优化或标记为优化重新编译的函数的消息，请忽略这些消息。有趣的一行是最后一行，它说add10已经被TurboFan成功优化。这符合我们的期望。请注意，每个现代JavaScript引擎都提供此行为。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add10000.js</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generate</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> s = <span class="string">&quot;(function add&quot;</span> + n + <span class="string">&quot;(x) &#123; return 0&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    s += <span class="string">&quot;+x&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  s += <span class="string">&quot;; &#125;)&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">eval</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add10000 = generate(<span class="number">10</span> * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span> * <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">  result += add10000(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们看看如果我们增加生成的函数的大小，使函数的码超字节码超过过TurboFan中的限制会发生什么情况。我们为此示例选择了一个任意数量的10000个加法。然后运行。。。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node --trace-opt add10000.js</span><br></pre></td></tr></table></figure>
<p>没有打印任何东西到控制台，这意味着add10000甚至没有被考虑由TurboFan（有些不幸，V8在这种情况下什么都没说，但只是默默地继续）。实际上，TurboFan甚至没有参与！相反，配置字节码执行的所谓RuntimeProfiler会立即决定函数太大，无法考虑进行优化，并禁用函数优化（在RuntimeProfiler::ShouldOptimize方法中）。</p>
<p>再次使用–print bytecode运行NodeJS，我们看到了罪魁祸首：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ node --print-bytecode add10000.js</span><br><span class="line">…</span><br><span class="line">[generated bytecode for function: add10000]</span><br><span class="line">Parameter count 2</span><br><span class="line">Frame size 8</span><br><span class="line">   18 E&gt; 0x2e785b7dcf22 @    0 : a0                StackCheck</span><br><span class="line">   24 S&gt; 0x2e785b7dcf23 @    1 : 0b                LdaZero</span><br><span class="line">         0x2e785b7dcf24 @    2 : 26 fb             Star r0</span><br><span class="line">         0x2e785b7dcf26 @    4 : 25 02             Ldar a0</span><br><span class="line">   32 E&gt; 0x2e785b7dcf28 @    6 : 32 fb 00          Add r0, [0]</span><br><span class="line">         0x2e785b7dcf2b @    9 : 26 fb             Star r0</span><br><span class="line">         0x2e785b7dcf2d @   11 : 25 02             Ldar a0</span><br><span class="line">   34 E&gt; 0x2e785b7dcf2f @   13 : 32 fb 01          Add r0, [1]</span><br><span class="line">…</span><br><span class="line">20026 E&gt; 0x2e785b7f52aa @ 99208 : 00 32 fb ff 0d 27 Add.Wide r0, [9997]</span><br><span class="line">         0x2e785b7f52b0 @ 99214 : 26 fb             Star r0</span><br><span class="line">         0x2e785b7f52b2 @ 99216 : 25 02             Ldar a0</span><br><span class="line">20028 E&gt; 0x2e785b7f52b4 @ 99218 : 00 32 fb ff 0e 27 Add.Wide r0, [9998]</span><br><span class="line">         0x2e785b7f52ba @ 99224 : 26 fb             Star r0</span><br><span class="line">         0x2e785b7f52bc @ 99226 : 25 02             Ldar a0</span><br><span class="line">20030 E&gt; 0x2e785b7f52be @ 99228 : 00 32 fb ff 0f 27 Add.Wide r0, [9999]</span><br><span class="line">20033 S&gt; 0x2e785b7f52c4 @ 99234 : a4                Return</span><br><span class="line">Constant pool (size &#x3D; 0)</span><br><span class="line">Handler Table (size &#x3D; 0)</span><br></pre></td></tr></table></figure>
<p>函数add10000生成了99235字节的字节码指令。这显然超过了RuntimeProfiler的60KB限制。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在v8:8598中有一个关于这个优化极限的讨论。一般来说，总会有某种形式的限制，因为这都是关于引擎的权衡。在V8的例子中，该限制允许TurboFan将各种计数（即中间表示中实体的输入和输出数量）存储为16位整数与32位整数。其他引擎和语言也有类似的限制。例如，在Java中，64KB方法限制甚至是JVM字节码规范的一部分。</p>
<h2 id="您可以从本节得到的收获"><a href="#您可以从本节得到的收获" class="headerlink" title="您可以从本节得到的收获"></a>您可以从本节得到的收获</h2><p>请确保将大型功能拆分为较小的构建基块。这通常是关于可维护性的好建议，但也有助于JIT正确地优化与应用程序相关的所有内容。较小的函数通常与 JIT 内部的内联机制配合良好，并且通常可以降低编译和优化的成本。想象一下，您有一个更大的函数，可以完成10个不同的任务。即使您只需要1到2个这样的任务，您仍然需要为编译函数中的所有内容支付成本（至少编译成字节码），而且由于内联启发式算法也考虑到了内联函数的大小，这样的函数在热调用站点内联的可能性几乎变得不太可能。</p>
<p>值得指出的是，在编写JavaScript时，通常您不会遇到60KB限制，除非在一些非常极端的情况下。但是以编程方式生成JavaScript的工具（即解析器生成器）非常容易达到这个限制。</p>
<h2 id="双字段"><a href="#双字段" class="headerlink" title="双字段"></a>双字段</h2><p>V8引擎使用一种称为指针标记的技术来编码任意JavaScript值。这里的技巧是，虽然指针可以用来寻址内存中的任何单个字节，但内存中的JavaScript对象不需要这样做，因为它们通常与字节边界对齐（即32位架构上的4字节对齐，64位架构中的8字节对齐）。因此，任何有效对象指针中的最低有效位都是零。V8使用这些位对其他信息进行编码。特别是它使用了两个最不显著的位来区分三种不同的值：</p>
<p><img src="/images/javascript-performance-pitfalls-v8/v8_memory_address.svg" alt="memory-address"></p>
<p>Smi是31位范围内的一个小整数，即-1073741824和10737418231之间的值，上移一位并在最低有效位中填充0。HeapObject指针是（管理）内存中对象的地址，其中两个最低有效位设置为01。这意味着当V8想要得到对象的真实地址时，它必须从值中减去一个地址。还有WeakHeapObject，它的最低有效位设置为11，本质上类似于HeapObject，只是垃圾收集器对引用的处理很弱。</p>
<p>在本文中，我们只关心Smi和HeapObject。鉴于小整数是JavaScript程序中最常见的数字值，因此有必要对它们进行有效的值编码。这就是为什么有特殊的Smi编码：这样小整数可以有效地存储，例如在对象内部。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">  x: <span class="number">42</span>,</span><br><span class="line">  y: <span class="string">&quot;Hello&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>考虑一下上面的对象。它有两个属性x和y，x有一个小的整数值，而y有一个字符串值。V8将在内存中表示该对象，如下所示：</p>
<p><img src="/images/javascript-performance-pitfalls-v8/object.svg" alt="object"></p>
<p>这里a被表示为一个JSObject，它的形态保存了关于a属性的信息，而属性的实际值在实例a中（您可以在我们以前的文章JavaScript引擎基础：形态和内联缓存以及JavaScript引擎基础：优化原型中读到更多关于形态的信息）。由于上面提到的值编码，小整数42可以有效地存储在JSObject内部，而字符串值必须在内存中表示为单独的实体，并由HeapObject指针指向。</p>
<p>现在对于那些看起来很明显并且有意义的字符串，将它们作为单独的实体进行分配，但是其他的数值呢？在JavaScript中，数字是64位双精度浮点值，因此它们可以对31位整数范围之外的许多值进行编码。在V8中使用的基本指针标记方案中，此范围之外的所有数字都必须表示为单独分配的HeapObject实体。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> b = &#123;</span><br><span class="line">  x: <span class="number">2</span> ** <span class="number">32</span>,</span><br><span class="line">  y: <span class="number">1.5</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在上面的b的例子中，我们给x分配了一个整数4294967296，它在31位整数范围之外，给y分配了一个甚至不是整数的数字。这两个值都不能使用有效的Smi编码，因此需要单独的堆分配实体，在V8中称为heapNumber：</p>
<p><img src="/images/javascript-performance-pitfalls-v8/heap_number.svg" alt="heap_number"></p>
<p>您可以想象，如果应用程序操作的数据结构主要由31位有符号整数范围之外的数值组成（即点、向量等），并且经常更新这些属性的值，那么代价是非常昂贵的。在这种情况下，对这些属性的每次更新都必须分配一个新的HeapNumber实体，因为这些实体本质上是不可变的（因为它们是传递的，因此可以从许多不同的地方引用）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> c = &#123;<span class="attr">x</span>: <span class="number">1.1</span>&#125;;</span><br><span class="line">c.x = <span class="number">1.2</span>;</span><br><span class="line">c.x = <span class="number">1.3</span>;</span><br></pre></td></tr></table></figure>
<p>运行这个简单的代码段将创建三个HeapNumber对象，分别对应于不同的数字1.1、1.2和1.3。</p>
<p><img src="/images/javascript-performance-pitfalls-v8/heap_number_example.svg" alt="heap_number_example"></p>
<p>总是不得不分配新的HeapNumbers是非常昂贵的，特别是对于数字应用程序，因为它会在垃圾收集器上造成大量的通信，并可能导致不良的缓存位置。</p>
<p>为了缓解在大量具有数字属性的对象上操作的应用程序的这个问题，V8有一个概念称为字段表示跟踪，它跟踪对象中每个字段的值的表示方式。具体来说，V8跟踪一个字段（如一个具体形状所描述的）到目前为止是否一直存储数字，在这里我们区分状态Smi和Double（前者意味着只看到小整数范围内的值，后者意味着也出现了该范围外的其他数字值）。具有Smi表示的字段已经如上所述高被效存储，但是优化编译器TurboFan可以使用字段表示信息来生成更高效的代码（即不需要检查字段是否包含整数，因为从形态上的表示中可以知道）。对于双字段，引入了一个新的MutableHeapNumber实体，该实体看起来像HeapNumber，但绑定到实例绑定并可以就地更新。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> c = &#123;<span class="attr">x</span>: <span class="number">1.1</span>&#125;;</span><br><span class="line">c.x = <span class="number">1.2</span>;</span><br><span class="line">c.x = <span class="number">1.3</span>;</span><br></pre></td></tr></table></figure>
<p>再看一下这个被更新的例子，我们发现只需要为double值分配一个存储，并且它刚刚被更新到最新的值：</p>
<p><img src="/images/javascript-performance-pitfalls-v8/heap_number_example_2.svg" alt="heap_number_example_2"></p>
<p>请注意现在属性信息如何将属性“x”标记为Double字段。</p>
<p>这个优化是由V8引擎完成的，作为一个开发人员，您甚至没有注意到它正在进行。更妙的是，在64位架构上，V8可以使用称为Double字段拆箱的技术将Double值内联存储到实例本身中。我不打算在这里描述这一点，因为其中的细节相当复杂。到目前为止，这应该是自动进行的并且它通常会为您做正确的事。</p>
<p>但它与任何启发式算法一样，都存在权衡。您可能已经在问自己，如何使用JavaScript的动态特性？特别是因为字段可以在任何给定的时间点保存任意值。比如说，如果您决定在某个时刻将一个字符串存储到c.x中呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.x = <span class="string">&quot;Hello&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>这在JavaScript中非常有效，V8通过如下字段表示的表格来处理这一点：</p>
<p><img src="/images/javascript-performance-pitfalls-v8/lattice.svg" alt="lattice"></p>
<p>对于每个字段，V8将根据存储的值选择最佳的表示形式，并并在必要时通过格子前进。就像将字符串存储到当前具有Double标记的字段中一样，它会将字段前进到标记的表示，这基本上可以说明任何内容。理想情况下，字段应该有Smi、Double或HeapObject表示标记之一（上面用橙色突出显示），也就是说，您不应该混合数字和其他值，以便在大多数情况下获得最佳性能。您可能已经了解了V8中元素种类的概念，这与字段表示机制非常相似。元素种类与数组索引属性有关，而字段表示用于非数组索引属性。</p>
<h2 id="混合数字和非数字字段"><a href="#混合数字和非数字字段" class="headerlink" title="混合数字和非数字字段"></a>混合数字和非数字字段</h2><p>当您将数字和非数字值都存储到字段中时，它的字段表示肯定会被标记，因为这是同时包含数字和非数字值的字段的唯一有效表示。如果这真的是您想做的，很好。但如果您真的打算操作数字值，那么混入非数值（包括未定义或空的原语）是个不太好的主意。性能方面，如果JavaScript引擎知道某个字段有Smi或Double表示，它可以跳过一系列检查。思考这个简单的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">distance</span>(<span class="params">p1, p2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dx = p1.x - p2.x;</span><br><span class="line">  <span class="keyword">const</span> dy = p1.y - p2.y;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(dx * dx + dy * dy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>计算两点p1和p2之间的距离。如果没有关于字段x和y的表示的任何附加信息，引擎将需要检查四个属性访问p1.x、p2.x、p1.y和p2.y的结果是否都产生了数字（并处理它们没有产生的情况）。</p>
<p>特别是不要用未定义（undefined）或空值（null）预先初始化数字字段，除非您的应用程序有必要这样做。话说回来，别做这种事</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.x = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">this</span>.y = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">setX</span>(<span class="params">x</span>)</span> &#123; <span class="built_in">this</span>.x = x; &#125;</span><br><span class="line">  <span class="function"><span class="title">setY</span>(<span class="params">y</span>)</span> &#123; <span class="built_in">this</span>.y = y; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>换言之，相比于使用null作为数字字段的初始值，更倾向于实际的数值，例如，可能是0（如果您计划使用小整数）或者0.1甚至NaN（如果您计划使用浮点）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.x = <span class="number">0.1</span>;</span><br><span class="line">    <span class="built_in">this</span>.y = <span class="number">0.1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">setX</span>(<span class="params">x</span>)</span> &#123; <span class="built_in">this</span>.x = x; &#125;</span><br><span class="line">  <span class="function"><span class="title">setY</span>(<span class="params">y</span>)</span> &#123; <span class="built_in">this</span>.y = y; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Smi到Double迁移"><a href="#Smi到Double迁移" class="headerlink" title="Smi到Double迁移"></a>Smi到Double迁移</h2><p>即使您注意到上面所说的，仍然有另一个微妙的问题，您可能会遇到与数字字段。例如，React团队最近就被这个问题所困扰。这里的微妙问题是，Smi和双字段表示法不兼容：前者要求将数字编码为字段中值的一部分，后者要求将数字存储在专用的MutableHeapNumber实体中。因此，从Smi到Double涉及到一个称为实例迁移的过程，在这个过程中，以前将值存储为Smi的实例需要迁移，以将字段值存储在MutableHeapNumber中。</p>
<p>这个过程包括为实例创建全新的形态，并在引擎命中实例时将实例从旧形态缓慢地迁移到新形态(在迁移开始时停止所有事情并在管理的内存中查找所有实例的代价太高了）。由于形态是在树中组织的（如JavaScript引擎基础：形状和内联缓存中所述），这可能涉及到创建新的形态子树。考虑以下两个对象o1和o2的示例，其中包含Smi字段x和y：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o1 = &#123;&#125;;</span><br><span class="line">o1.x = <span class="number">3</span>;</span><br><span class="line">o1.y = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> o2 = &#123;&#125;;</span><br><span class="line">o2.x = <span class="number">5</span>;</span><br><span class="line">o2.y = <span class="number">6</span>;</span><br></pre></td></tr></table></figure>
<p>这会在以下描述的这些形态之间创建适当的形态和过渡：</p>
<p><img src="/images/javascript-performance-pitfalls-v8/double_shape.svg" alt="double_shape"></p>
<p>现在想象一下，我们把o2.x的值改为5.5，这不能用这样的Smi来表示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o2.x = <span class="number">5.5</span>;</span><br></pre></td></tr></table></figure>
<p>现在，V8必须从引入属性x的形态开始创建一个全新的子树，并让o2使用新的形态。实例o1仍然指向上一个形态，它现在被标记为已弃用。</p>
<p><img src="/images/javascript-performance-pitfalls-v8/shape_sub_tree.svg" alt="shape_sub_tree"></p>
<p>如图所示，旧形态子树基本上与根形态断开，取而代之的是一个新的形态子树。旧子树的所有形态都标为弃用，一旦不再有实例使用它们，最终将会被垃圾收集。然而，在此期间，会有额外的开销保持两个单独的元数据树存活。</p>
<p>下次任何IC（内联缓存）看到o1时，它会自动将实例从不推荐使用的形态迁移到其所谓的迁移目标，即新子树中的相应形态。例如，如果您现在执行像o1.y这样的属性访问，它将自动执行自我修复。您甚至不需要储存它，从中加载任何属性就足够了。这也迫使o1.x变成一个Double字段表示，这样之后o1和o2再次使用相同的形状：</p>
<p><img src="/images/javascript-performance-pitfalls-v8/double_field.svg" alt="double_field"></p>
<p>现在想象一下，当需要对成千上万个拥有大量属性的对象执行此操作时会发生什么情况，这有点类似于facebook/react#14365中的情况，只是在他们的情况下，这是些糟糕的互操作伴随着Object.preventExtensions()在上面，其中V8中的一个bug导致它以某种方式错过了正确的迁移目标，因此V8最终为这个应用程序中的每个FiberNode实例分配了一个新的唯一形态。相关问题v8:8538仍在调查中。</p>
<p>这里给您的可操作建议是，无论何时使用字段来保存任意数字值（包括小整数范围之外的值），请使用非小整数初始化此字段。这样，您就可以从一开始就获得正确的形态，并且可以避免迁移成本（和麻烦）。实现这一点的一个简单方法是在初始化时存储NaN，这也是React对问题的解决方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">x, y</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.x = <span class="literal">NaN</span>; <span class="built_in">this</span>.x = x;</span><br><span class="line">    <span class="built_in">this</span>.y = <span class="literal">NaN</span>; <span class="built_in">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但也像所有性能建议一样：不要到处盲目地这样做。您的许多代码可能都是好的，不会受到性能的影响，即使对象有时会进行迁移。</p>
<h2 id="您可以从本节得到的收获-1"><a href="#您可以从本节得到的收获-1" class="headerlink" title="您可以从本节得到的收获"></a>您可以从本节得到的收获</h2><p>尽量避免混合不同类型的字段值，即不要混合数字、字符串、对象和其他原始值，除非您打算这样做。具体来说，不要将数字字段预初始化为null或undefined，而是选择合理的默认数字（如果有疑问，请使用NaN）。并尝试用小整数范围外的Double值来初始化Double值字段（也就是应该包含小整数范围外的数值的字段），也就是说，如果有疑问，首先在那里输入一个NaN，然后存储实际的初始值。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>您应该相信 JavaScript 引擎通常会自动为您做正确的事。但与一切一样，了解一些细节是有好处的，所以万一遇到问题，您会找到解决的方法，有时如果启发式算法失败的话，给JavaScript引擎一个额外的提示可能是有益的。</p>
<h2 id="附注"><a href="#附注" class="headerlink" title="附注"></a>附注</h2><ul>
<li>在撰写本文时，64位架构上的s是32位范围内的整数，但在不久的将来，这可能会改变为在future.Smi的任何地方都使用31位范围内的整数</li>
<li>尽管也有JavaScript虚拟机设法存储编码到值本身的短字符串，例如V7嵌入式JavaScript引擎就可以做到这一点。</li>
<li>这里的选择是完全武断的，这只是我会这么做的方式，因为它标志着我未来的自我阅读这些代码，我没有不小心的立即地覆盖该值，而是故意这样做的。您可以在这里使用任何非小整数，换言之，NaN 0.1 Number.MAX_VALUE -0可以全部在这里工作。</li>
</ul>
<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>原文：<a target="_blank" rel="noopener" href="https://ponyfoo.com/articles/javascript-performance-pitfalls-v8#optimization-limit">JavaScript Performance Pitfalls in V8</a></p>
<p>翻译：<a target="_blank" rel="noopener" href="https://siyuan.pub/">SiYuanPub</a></p>
</div><div class="article-licensing box"><div class="licensing-title"><p>V8 中的 JavaScript 性能陷阱</p><p><a href="http://example.com/2021/04/26/javascript-performance-pitfalls-v8/">http://example.com/2021/04/26/javascript-performance-pitfalls-v8/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>SiYuan Zhong</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-04-26</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-05-31</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/v8-engine-optimization/">v8 engine optimization</a></div><div class="sharethis-inline-share-buttons"></div><script src="http://siyuan.pub" defer></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/images/alipay.png" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/images/wechatpay.png" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/05/31/upgrade/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">前端之路：如何做好一个npm时代的前端程序员</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/04/25/async/"><span class="level-item">通过BabelPolyfill理解Await工作原理</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div><script>var disqus_config = function () {
            this.page.url = 'http://example.com/2021/04/26/javascript-performance-pitfalls-v8/';
            this.page.identifier = '2021/04/26/javascript-performance-pitfalls-v8/';
        };
        (function() {
            var d = document, s = d.createElement('script');  
            s.src = '//' + 'siyuan-pub' + '.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/images/avatar.jpg" alt="SiYuan Zhong"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">SiYuan Zhong</p><p class="is-size-6 is-block">Web Developer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Earth, Solar System</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">2</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">4</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/zhongsiyuan" target="_blank" rel="noopener">关注我</a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/JavaScriptBasic/"><span class="level-start"><span class="level-item">JavaScriptBasic</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/upgrade/"><span class="level-start"><span class="level-item">upgrade</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-05-31T04:42:28.000Z">2021-05-31</time></p><p class="title"><a href="/2021/05/31/upgrade/">前端之路：如何做好一个npm时代的前端程序员</a></p><p class="categories"><a href="/categories/upgrade/">upgrade</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-04-25T16:42:28.000Z">2021-04-26</time></p><p class="title"><a href="/2021/04/26/javascript-performance-pitfalls-v8/">V8 中的 JavaScript 性能陷阱</a></p><p class="categories"><a href="/categories/JavaScriptBasic/">JavaScriptBasic</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-04-25T14:08:45.981Z">2021-04-25</time></p><p class="title"><a href="/2021/04/25/async/">通过BabelPolyfill理解Await工作原理</a></p><p class="categories"><a href="/categories/JavaScriptBasic/">JavaScriptBasic</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-03-25T03:14:28.000Z">2021-03-25</time></p><p class="title"><a href="/2021/03/25/context/">深入剖析原型与原型链</a></p><p class="categories"><a href="/categories/JavaScriptBasic/">JavaScriptBasic</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">五月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">四月 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">三月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/async/"><span class="tag">async</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/prototype/"><span class="tag">prototype</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/upgrade/"><span class="tag">upgrade</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/v8-engine-optimization/"><span class="tag">v8 engine optimization</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/brand.png" alt="SiYuanPublic" height="28"></a><p class="is-size-7"><span>&copy; 2021 SiYuan Zhong</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>