{"pages":[],"posts":[{"title":"通过BabelPolyfill理解Await工作原理","text":"现今前端工程实践中，由于Babel的出现，各种ES的新特性大行其道。 处理异步逻辑的方式也由最初的Callback思想，过渡到Promise方案，再到如今最流行的Async/Await。 实际上，根据Promise A+规范说明，Promise也是Callback方案，不少社区开发者声称Async/Await是Promise的语法糖，事实如此吗？ 我们今天使用BabelPolyfill和一个简单的用例，将代码转为支持Chrome54版本的语法*注(Chrome54不支持Async/Await)，来进一步验证Async/Await的内部原理。 123456789101112131415161718192021async function main() { console.log('main-env'); const fn1Result = await fn1(); console.log(fn1Result, 'fn1Result'); const fn2Result = await fn2(); console.log(fn2Result, 'fn2Result');}function fn1() { console.log('fn1-env'); return 'success-fn1';}async function fn2() { console.log('fn2-env'); return 'success-fn2';}main();console.log('global-env'); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; console.log(info, arguments); } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); }}function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, &quot;next&quot;, value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, &quot;throw&quot;, err); } _next(undefined); }); };}function main() { return _main.apply(this, arguments);}function _main() { _main = _asyncToGenerator(function* () { console.log('main-env'); const fn1Result = yield fn1(); console.log(fn1Result, 'fn1Result'); const fn2Result = yield fn2(); console.log(fn2Result, 'fn2Result'); }); return _main.apply(this, arguments);}function fn1() { console.log('fn1-env'); return 'success-fn1';}function fn2() { return _fn.apply(this, arguments);}function _fn() { _fn = _asyncToGenerator(function* () { console.log('fn2-env'); return 'success-fn2'; }); return _fn.apply(this, arguments);}main();console.log('global-env');//# sourceMappingURL=async-post.es.js.map 通过上述代码可以看出，实际Async/Await是使用Generator + Promise，通过递归不停的调用Generator中的Next函数，直到返回Done。 那么处在每个被Yield关键字描述的语句的上一段落，就会逐行执行。如果被Yield关键字描述的方法中依旧存在异步内容，则再次被压入执行栈中并执行。 所以我们可以认为，被Await关键字描述的语句后的段落，实际上相当于书写在Promise.then中。 并且，查看被babel重新编译后的代码，对比函数fn1与async fn2可以看出，一个被Async关键字描述的方法，则一定会返回一个Promise。","link":"/2021/04/25/async/"},{"title":"深入剖析原型与原型链","text":"MDN对JavaScript的描述是 基于原型 的脚本语言。 熟悉前端领域的同学们应该都听说过原型和原型链的概念，出于学习交流的目的，这篇文章用于梳理笔者对原型/原型链的个人理解。 首先需要明确的是：在JavaScript中，我们认为一切都是对象实例。关于这段话的解释如下： 123456789// fn 是 Function构造函数的实例。 注：与使用new操作符构造的Function实例对象的区别是，new Function返回的是匿名的funcition实例对象function fn() {};// fnInstance 是 Fn构造函数的实例。 注：function Fn()与function fn()没有本质的区别，只是在开发中，如果采用全驼峰式写法，表示该函数为构造函数。function Fn() {};const fnInstance = new Fn();// str 是 String构造函数的实例。const str = 'str'; 原型是JS实现继承的基石通常，所有构造函数都存在一个prototype属性，prototype实际上就是大家通常说的原型对象。实际上准确来讲，prototype属性是一个引用类型，指向一个原型对象。 我们就可以认为，这个原型对象就是这个构造函数的一个属性，这个属性存在一个特殊的描述，叫做原型。 prototype， [[prototype]] 与 __proto__首先介绍一下__proto__，其本身最初并不是ES标准的一部分，起初由各浏览器厂商对对象实例的[[prototype]]进行了实现，便于开发者进行调试使用。最终ES基金会将这一实现标准化，所以在浏览器中，x.proto === Object.getPrototypeOf(x)。其内部实现是采用了Object.defineProperty的getter与Object.getPrototypeOf()方法。 由构造函数实例化的对象实例，也存在一个引用类型的属性，叫做[[prototype]]属性，它也指向了构造函数prototype所指向的原型对象。这样所有被该构造函数实例化的对象，都共享了这个原型属性。 构造函数在JavaScript中是Function构造函数的实例，所以以下表达式结果为真。 123function fn() {}Object.getPrototypeOf(fn) === Function.prototype; 需要特殊说明的是，原型对象中存在两个特殊的属性。 constructor 该属性指向了引用它的构造函数本身 [[prototype]] 该属性指向了引用它的构造函数*注(该构造函数是父构造函数的对象实例)的构造函数 如下所示，使用new操作符时，fn是fnInstance实例对象的构造函数，fnInstance的[[prototype]]属性，是指向fn.prototype的指针。 所有实例对象（fnInstance）都存在[[prototype]]属性，原型对象（fnInstanceProto）也不例外，因为原型也是实例对象。原型对象的[[prototype]]指向该实例对象（fnInstance）构造函数原型（fn.prototype）的[[prototype]] 1234567891011121314function fn() {}// 原型对象内部结构// fn.prototype = {// constructor: fn,// [[prototype]]: Object.prototype,// }fn.prototype.constructor === fn;Object.getPrototypeOf(fn.prototype) === Object.prototype;const fnInstance = new fn();const fnInstanceProto = Object.getPrototypeOf(fnInstance); 原型链与继承JavaScript在访问实例自身属性/方法时，如果不存在该属性/方法，就会查找并返回该实例对象的[[prototype]]属性所指向的原型对象中的属性，如果构造函数本身原型对象属性上也没有该属性/方法，则查找该构造函数prototype属性所指向的原型对象的[[prototype]]中的属性/方法，即该实例对象构造函数的构造函数的原型对象中的属性/方法。查找规则为向上递归查找，直到查找到null为止。 这种原型的层层引用关系，组成了原型链。即原型链是实现JS继承的机制。 原型链图解","link":"/2021/03/25/context/"},{"title":"V8 中的 JavaScript 性能陷阱","text":"近年来，JavaScript引擎在各个方面都有所改进。JavaScript的性能已经达到了可以轻松与传统上被认为更适合高性能计算的编程语言竞争的水平。这不仅适用于V8，Chrome和Linux内部的JavaScript引擎Node.js，并且适用于几乎所有主要的JavaScript引擎，包括ChakraCore，Edge的内部的引擎，JavaScriptCore，Safari内部的引擎，以及SpiderMonkey，Firefox内部的引擎。 不仅峰值性能得到了改善，而且引擎还实现了更一致和可预测的性能水平。鉴于JavaScript是一种高度动态的语言，所有这些性能都基于在引擎中选择正确的启发式算法。JavaScript引擎使用预测优化和内联缓存等技术来加速执行可能的途径。 但是启发式算法也可以很容易对产生你不利，这将帮助你了解他们。所以今天我将分享一些关于v8引擎中两个微妙性能缺陷的背景知识。意识到这些潜在的陷阱可能会帮助你解决问题，如果你更容易踩到这些陷阱的话。 优化限制V8中内置的编译器（TurboFan优化编译器和Ignition节码生成器）是被称为JIT的方法。这意味着编译单位始终是一种方法，也就是JavaScript中的函数。当优化编译器发现热调用站点并通过这样做（通常称为内联）进一步优化的潜力时，它能够包括其他方法的主体。与此相比，使用所谓的跟踪 JIT的其他运行时间 - LuaJIT和PyPy是这里比较流行的示例，其中优化的单位是以前重复执行的连续字节码的任意序列。 在方法JIT和跟踪JIT中，优化器可以处理的输入大小总是有一个上限。对于方法JIT，这个限制自然由函数本身的大小定义。TurboFan也有这样一个限制，目前是60KB字节码（在runtime-profiler.cc中的kMaxBytecodeSizeForOpt常量）-profiler.cc). 也就是说，如果你的函数生成的字节码大于60KB，它们将永远不会被TurboFan优化，即使它们被认为是热的（即经常调用）。 让我们思考一个例子，使用eval动态生成函数(我们故意不在这里使用函数构造器，因为这不允许我们在JavaScript引擎语法上对可以识别的函数的上加上一个名称，这将使研究变得非常具有挑战性）。 12345678function generate(n) { let s = &quot;(function add&quot; + n + &quot;(x) { return 0&quot;; for (let i = 0; i &lt; n; ++i) { s += &quot;+x&quot;; } s += &quot;; })&quot;; return eval(s);} 这个generate函数构造了一个新的JavaScript函数对象，将传递给它的参数相加n次。因此，当您调用generate(10)时，您将得到一个如下所示的函数对象： 123function add10(x) { return 0+x+x+x+x+x+x+x+x+x+x;} 现在让我们以上面的一个具体例子来将它运行在NodeJS中: 12345678910111213// add10.jsfunction generate(n) { let s = &quot;(function add&quot; + n + &quot;(x) { return 0&quot;; for (let i = 0; i &lt; n; ++i) { s += &quot;+x&quot;; } s += &quot;; })&quot;; return eval(s);}const add10 = generate(10);add10(); 查看add10函数生成的字节码，在node shell中使用–print bytecode命令，我们看到如下内容（输出来自NodeJS v10.15）： 1234567891011121314151617181920212223242526272829303132333435363738394041$ node --print-bytecode add10.js…[generated bytecode for function: add10]Parameter count 2Frame size 8 19 E&gt; 0x279c523204b2 @ 0 : a5 StackCheck 26 S&gt; 0x279c523204b3 @ 1 : 0b LdaZero 0x279c523204b4 @ 2 : 26 fb Star r0 0x279c523204b6 @ 4 : 25 02 Ldar a0 34 E&gt; 0x279c523204b8 @ 6 : 34 fb 00 Add r0, [0] 0x279c523204bb @ 9 : 26 fb Star r0 0x279c523204bd @ 11 : 25 02 Ldar a0 36 E&gt; 0x279c523204bf @ 13 : 34 fb 01 Add r0, [1] 0x279c523204c2 @ 16 : 26 fb Star r0 0x279c523204c4 @ 18 : 25 02 Ldar a0 38 E&gt; 0x279c523204c6 @ 20 : 34 fb 02 Add r0, [2] 0x279c523204c9 @ 23 : 26 fb Star r0 0x279c523204cb @ 25 : 25 02 Ldar a0 40 E&gt; 0x279c523204cd @ 27 : 34 fb 03 Add r0, [3] 0x279c523204d0 @ 30 : 26 fb Star r0 0x279c523204d2 @ 32 : 25 02 Ldar a0 42 E&gt; 0x279c523204d4 @ 34 : 34 fb 04 Add r0, [4] 0x279c523204d7 @ 37 : 26 fb Star r0 0x279c523204d9 @ 39 : 25 02 Ldar a0 44 E&gt; 0x279c523204db @ 41 : 34 fb 05 Add r0, [5] 0x279c523204de @ 44 : 26 fb Star r0 0x279c523204e0 @ 46 : 25 02 Ldar a0 46 E&gt; 0x279c523204e2 @ 48 : 34 fb 06 Add r0, [6] 0x279c523204e5 @ 51 : 26 fb Star r0 0x279c523204e7 @ 53 : 25 02 Ldar a0 48 E&gt; 0x279c523204e9 @ 55 : 34 fb 07 Add r0, [7] 0x279c523204ec @ 58 : 26 fb Star r0 0x279c523204ee @ 60 : 25 02 Ldar a0 50 E&gt; 0x279c523204f0 @ 62 : 34 fb 08 Add r0, [8] 0x279c523204f3 @ 65 : 26 fb Star r0 0x279c523204f5 @ 67 : 25 02 Ldar a0 52 E&gt; 0x279c523204f7 @ 69 : 34 fb 09 Add r0, [9] 55 S&gt; 0x279c523204fa @ 72 : a9 ReturnConstant pool (size = 0)Handler Table (size = 0)… 由于NodeJS运行了很多自己的JavaScript，您可能会在这里获得输出页面。搜索短语[generated bytecode for function: add10]，其中下面的字节码转储包含10个加法序列，中间包含Star字节码和Ldar字节码。 除去不相关的部分，我们可以看到具体的字节码输出： 123456789101112131415161718192021222324252627282930313233 0 : a5 StackCheck 1 : 0b LdaZero 2 : 26 fb Star r0 4 : 25 02 Ldar a0 6 : 34 fb 00 Add r0, [0] 9 : 26 fb Star r011 : 25 02 Ldar a013 : 34 fb 01 Add r0, [1]16 : 26 fb Star r018 : 25 02 Ldar a020 : 34 fb 02 Add r0, [2]23 : 26 fb Star r025 : 25 02 Ldar a027 : 34 fb 03 Add r0, [3]30 : 26 fb Star r032 : 25 02 Ldar a034 : 34 fb 04 Add r0, [4]37 : 26 fb Star r039 : 25 02 Ldar a041 : 34 fb 05 Add r0, [5]44 : 26 fb Star r046 : 25 02 Ldar a048 : 34 fb 06 Add r0, [6]51 : 26 fb Star r053 : 25 02 Ldar a055 : 34 fb 07 Add r0, [7]58 : 26 fb Star r060 : 25 02 Ldar a062 : 34 fb 08 Add r0, [8]65 : 26 fb Star r067 : 25 02 Ldar a069 : 34 fb 09 Add r0, [9]72 : a9 Return 查看上面的输出，我们看到生成的字节代码为 73 字节大小（72 是字节代码的偏移，该指令的大小为 1 字节）。考虑到我们之前了解到关于TurboFan的60KB极限的情况，这个功能应该可以被TurboFan轻松优化。让我们试着看看如果我们把这个函数放到一个热循环中会发生什么。 1234567891011121314151617// add10-optimized.jsfunction generate(n) { let s = &quot;(function add&quot; + n + &quot;(x) { return 0&quot;; for (let i = 0; i &lt; n; ++i) { s += &quot;+x&quot;; } s += &quot;; })&quot;; return eval(s);}const add10 = generate(10);let result = 0;for (let i = 0; i &lt; 5 * 1000; ++i) { result += add10(i);} 在NodeJS内部运行此代码段，并传递–trace opt命令行参数，我们会看到类似于以下输出的内容： 12345$ node --trace-opt add10-optimized.js[marking 0x32fc83347751 &lt;JSFunction add10 (sfi = 0x32fcde157b91)&gt; for optimized recompilation, reason: small function, ICs with typeinfo: 10/10 (100%), generic ICs: 0/10 (0%)][compiling method 0x32fc83347751 &lt;JSFunction add10 (sfi = 0x32fcde157b91)&gt; using TurboFan][optimizing 0x32fc83347751 &lt;JSFunction add10 (sfi = 0x32fcde157b91)&gt; - took 0.823, 0.514, 0.016 ms][completed optimizing 0x32fc83347751 &lt;JSFunction add10 (sfi = 0x32fcde157b91)&gt;] 您可能会看到关于其他正在优化或标记为优化重新编译的函数的消息，请忽略这些消息。有趣的一行是最后一行，它说add10已经被TurboFan成功优化。这符合我们的期望。请注意，每个现代JavaScript引擎都提供此行为。 1234567891011121314151617// add10000.jsfunction generate(n) { let s = &quot;(function add&quot; + n + &quot;(x) { return 0&quot;; for (let i = 0; i &lt; n; ++i) { s += &quot;+x&quot;; } s += &quot;; })&quot;; return eval(s);}const add10000 = generate(10 * 1000);let result = 0;for (let i = 0; i &lt; 5 * 1000; ++i) { result += add10000(i);} 让我们看看如果我们增加生成的函数的大小，使函数的码超字节码超过过TurboFan中的限制会发生什么情况。我们为此示例选择了一个任意数量的10000个加法。然后运行。。。 1node --trace-opt add10000.js 没有打印任何东西到控制台，这意味着add10000甚至没有被考虑由TurboFan（有些不幸，V8在这种情况下什么都没说，但只是默默地继续）。实际上，TurboFan甚至没有参与！相反，配置字节码执行的所谓RuntimeProfiler会立即决定函数太大，无法考虑进行优化，并禁用函数优化（在RuntimeProfiler::ShouldOptimize方法中）。 再次使用–print bytecode运行NodeJS，我们看到了罪魁祸首： 123456789101112131415161718192021222324$ node --print-bytecode add10000.js…[generated bytecode for function: add10000]Parameter count 2Frame size 8 18 E&gt; 0x2e785b7dcf22 @ 0 : a0 StackCheck 24 S&gt; 0x2e785b7dcf23 @ 1 : 0b LdaZero 0x2e785b7dcf24 @ 2 : 26 fb Star r0 0x2e785b7dcf26 @ 4 : 25 02 Ldar a0 32 E&gt; 0x2e785b7dcf28 @ 6 : 32 fb 00 Add r0, [0] 0x2e785b7dcf2b @ 9 : 26 fb Star r0 0x2e785b7dcf2d @ 11 : 25 02 Ldar a0 34 E&gt; 0x2e785b7dcf2f @ 13 : 32 fb 01 Add r0, [1]…20026 E&gt; 0x2e785b7f52aa @ 99208 : 00 32 fb ff 0d 27 Add.Wide r0, [9997] 0x2e785b7f52b0 @ 99214 : 26 fb Star r0 0x2e785b7f52b2 @ 99216 : 25 02 Ldar a020028 E&gt; 0x2e785b7f52b4 @ 99218 : 00 32 fb ff 0e 27 Add.Wide r0, [9998] 0x2e785b7f52ba @ 99224 : 26 fb Star r0 0x2e785b7f52bc @ 99226 : 25 02 Ldar a020030 E&gt; 0x2e785b7f52be @ 99228 : 00 32 fb ff 0f 27 Add.Wide r0, [9999]20033 S&gt; 0x2e785b7f52c4 @ 99234 : a4 ReturnConstant pool (size = 0)Handler Table (size = 0) 函数add10000生成了99235字节的字节码指令。这显然超过了RuntimeProfiler的60KB限制。 背景在v8:8598中有一个关于这个优化极限的讨论。一般来说，总会有某种形式的限制，因为这都是关于引擎的权衡。在V8的例子中，该限制允许TurboFan将各种计数（即中间表示中实体的输入和输出数量）存储为16位整数与32位整数。其他引擎和语言也有类似的限制。例如，在Java中，64KB方法限制甚至是JVM字节码规范的一部分。 你可以从本节得到的收获请确保将大型功能拆分为较小的构建基块。这通常是关于可维护性的好建议，但也有助于JIT正确地优化与应用程序相关的所有内容。较小的函数通常与 JIT 内部的内联机制配合良好，并且通常可以降低编译和优化的成本。想象一下，你有一个更大的函数，可以完成10个不同的任务。即使你只需要1到2个这样的任务，你仍然需要为编译函数中的所有内容支付成本（至少编译成字节码），而且由于内联启发式算法也考虑到了内联函数的大小，这样的函数在热调用站点内联的可能性几乎变得不太可能。 值得指出的是，在编写JavaScript时，通常您不会遇到60KB限制，除非在一些非常极端的情况下。但是以编程方式生成JavaScript的工具（即解析器生成器）非常容易达到这个限制。 双字段V8引擎使用一种称为指针标记的技术来编码任意JavaScript值。这里的技巧是，虽然指针可以用来寻址内存中的任何单个字节，但内存中的JavaScript对象不需要这样做，因为它们通常与字边界对齐（即32位架构上的4字节对齐，64位架构中的8字节对齐）。因此，任何有效对象指针中的最低有效位都是零。V8使用这些位对其他信息进行编码。特别是它使用了两个最不显著的位来区分三种不同的值： Smi是31位范围内的一个小整数，即-1073741824和10737418231之间的值，上移一位并在最低有效位中填充0。HeapObject指针是（管理）内存中对象的地址，其中两个最低有效位设置为01。这意味着当V8想要得到对象的真实地址时，它必须从值中减去一个地址。还有WeakHeapObject，它的最低有效位设置为11，本质上类似于HeapObject，只是垃圾收集器对引用的处理很弱。 在本文中，我们只关心Smi和HeapObject。鉴于小整数是JavaScript程序中最常见的数字值，因此有必要对它们进行有效的值编码。这就是为什么有特殊的Smi编码：这样小整数可以有效地存储，例如在对象内部。 1234const a = { x: 42, y: &quot;Hello&quot;}; 考虑一下上面的对象。它有两个属性x和y，x有一个小的整数值，而y有一个字符串值。V8将在内存中表示该对象，如下所示： 这里a被表示为一个JSObject，它的形态保存了关于a属性的信息，而属性的实际值在实例a中（您可以在我们以前的文章JavaScript引擎基础：形态和内联缓存以及JavaScript引擎基础：优化原型中读到更多关于形态的信息）。由于上面提到的值编码，小整数42可以有效地存储在JSObject内部，而字符串值必须在内存中表示为单独的实体，并由HeapObject指针指向。 现在对于那些看起来很明显并且有意义的字符串，将它们作为单独的实体进行分配，但是其他的数值呢？在JavaScript中，数字是64位双精度浮点值，因此它们可以对31位整数范围之外的许多值进行编码。在V8中使用的基本指针标记方案中，此范围之外的所有数字都必须表示为单独分配的HeapObject实体。 1234const b = { x: 2 ** 32, y: 1.5}; 在上面的b的例子中，我们给x分配了一个整数4294967296，它在31位整数范围之外，给y分配了一个甚至不是整数的数字。这两个值都不能使用有效的Smi编码，因此需要单独的堆分配实体，在V8中称为heapNumber： 您可以想象，如果应用程序操作的数据结构主要由31位有符号整数范围之外的数值组成（即点、向量等），并且经常更新这些属性的值，那么代价是非常昂贵的。在这种情况下，对这些属性的每次更新都必须分配一个新的HeapNumber实体，因为这些实体本质上是不可变的（因为它们是传递的，因此可以从许多不同的地方引用）。 123const c = {x: 1.1};c.x = 1.2;c.x = 1.3; 运行这个简单的代码段将创建三个HeapNumber对象，分别对应于不同的数字1.1、1.2和1.3。 总是不得不分配新的HeapNumbers是非常昂贵的，特别是对于数字应用程序，因为它会在垃圾收集器上造成大量的通信，并可能导致不良的缓存位置。 为了缓解在大量具有数字属性的对象上操作的应用程序的这个问题，V8有一个概念称为字段表示跟踪，它跟踪对象中每个字段的值的表示方式。具体来说，V8跟踪一个字段（如一个具体形状所描述的）到目前为止是否一直存储数字，在这里我们区分状态Smi和Double（前者意味着只看到小整数范围内的值，后者意味着也出现了该范围外的其他数字值）。具有Smi表示的字段已经如上所述高被效存储，但是优化编译器TurboFan可以使用字段表示信息来生成更高效的代码（即不需要检查字段是否包含整数，因为从形态上的表示中可以知道）。对于双字段，引入了一个新的MutableHeapNumber实体，该实体看起来像HeapNumber，但绑定到实例绑定并可以就地更新。 123const c = {x: 1.1};c.x = 1.2;c.x = 1.3; 再看一下这个被更新的例子，我们发现只需要为double值分配一个存储，并且它刚刚被更新到最新的值： 请注意现在属性信息如何将属性“x”标记为Double字段。 这个优化是由V8引擎完成的，作为一个开发人员，你甚至没有注意到它正在进行。更妙的是，在64位架构上，V8可以使用称为Double字段拆箱的技术将Double值内联存储到实例本身中。我不打算在这里描述这一点，因为其中的细节相当复杂。到目前为止，这应该是自动进行的并且它通常会为你做正确的事。 但它与任何启发式算法一样，都存在权衡。您可能已经在问自己，如何使用JavaScript的动态特性？特别是因为字段可以在任何给定的时间点保存任意值。比如说，如果你决定在某个时刻将一个字符串存储到c.x中呢？ 1c.x = &quot;Hello&quot;; 这在JavaScript中非常有效，V8通过如下字段表示的表格来处理这一点： 对于每个字段，V8将根据存储的值选择最佳的表示形式，并并在必要时通过格子前进。就像将字符串存储到当前具有Double标记的字段中一样，它会将字段前进到标记的表示，这基本上可以说明任何内容。理想情况下，字段应该有Smi、Double或HeapObject表示标记之一（上面用橙色突出显示），也就是说，您不应该混合数字和其他值，以便在大多数情况下获得最佳性能。您可能已经了解了V8中元素种类的概念，这与字段表示机制非常相似。元素种类与数组索引属性有关，而字段表示用于非数组索引属性。 混合数字和非数字字段当您将数字和非数字值都存储到字段中时，它的字段表示肯定会被标记，因为这是同时包含数字和非数字值的字段的唯一有效表示。如果这真的是你想做的，很好。但如果您真的打算操作数字值，那么混入非数值（包括未定义或空的原语）是个不太好的主意。性能方面，如果JavaScript引擎知道某个字段有Smi或Double表示，它可以跳过一系列检查。思考这个简单的例子： 12345function distance(p1, p2) { const dx = p1.x - p2.x; const dy = p1.y - p2.y; return Math.sqrt(dx * dx + dy * dy);} 计算两点p1和p2之间的距离。如果没有关于字段x和y的表示的任何附加信息，引擎将需要检查四个属性访问p1.x、p2.x、p1.y和p2.y的结果是否都产生了数字（并处理它们没有产生的情况）。 特别是不要用未定义（undefined）或空值（null）预先初始化数字字段，除非您的应用程序有必要这样做。话说回来，别做这种事 123456789class Point { constructor() { this.x = null; this.y = null; } setX(x) { this.x = x; } setY(y) { this.y = y; }} 换言之，相比于使用null作为数字字段的初始值，更倾向于实际的数值，例如，可能是0（如果你计划使用小整数）或者0.1甚至NaN（如果你计划使用浮点）。 123456789class Point { constructor() { this.x = 0.1; this.y = 0.1; } setX(x) { this.x = x; } setY(y) { this.y = y; }} Smi到Double迁移即使你注意到上面所说的，仍然有另一个微妙的问题，你可能会遇到与数字字段。例如，React团队最近就被这个问题所困扰。这里的微妙问题是，Smi和双字段表示法不兼容：前者要求将数字编码为字段中值的一部分，后者要求将数字存储在专用的MutableHeapNumber实体中。因此，从Smi到Double涉及到一个称为实例迁移的过程，在这个过程中，以前将值存储为Smi的实例需要迁移，以将字段值存储在MutableHeapNumber中。 这个过程包括为实例创建全新的形态，并在引擎命中实例时将实例从旧形态缓慢地迁移到新形态(在迁移开始时停止所有事情并在管理的内存中查找所有实例的代价太高了）。由于形态是在树中组织的（如JavaScript引擎基础：形状和内联缓存中所述），这可能涉及到创建新的形态子树。考虑以下两个对象o1和o2的示例，其中包含Smi字段x和y： 1234567const o1 = {};o1.x = 3;o1.y = 4;const o2 = {};o2.x = 5;o2.y = 6; 这会在以下描述的这些形态之间创建适当的形态和过渡： 现在想象一下，我们把o2.x的值改为5.5，这不能用这样的Smi来表示： 1o2.x = 5.5; 现在，V8必须从引入属性x的形态开始创建一个全新的子树，并让o2使用新的形态。实例o1仍然指向上一个形态，它现在被标记为已弃用。 如图所示，旧形态子树基本上与根形态断开，取而代之的是一个新的形态子树。旧子树的所有形态都标为弃用，一旦不再有实例使用它们，最终将会被垃圾收集。然而，在此期间，会有额外的开销保持两个单独的元数据树存活。 下次任何IC（内联缓存）看到o1时，它会自动将实例从不推荐使用的形态迁移到其所谓的迁移目标，即新子树中的相应形态。例如，如果您现在执行像o1.y这样的属性访问，它将自动执行自我修复。你甚至不需要储存它，从中加载任何属性就足够了。这也迫使o1.x变成一个Double字段表示，这样之后o1和o2再次使用相同的形状： 现在想象一下，当需要对成千上万个拥有大量属性的对象执行此操作时会发生什么情况，这有点类似于facebook/react#14365中的情况，只是在他们的情况下，这是些糟糕的互操作伴随着Object.preventExtensions()在上面，其中V8中的一个bug导致它以某种方式错过了正确的迁移目标，因此V8最终为这个应用程序中的每个FiberNode实例分配了一个新的唯一形态。相关问题v8:8538仍在调查中。 这里给您的可操作建议是，无论何时使用字段来保存任意数字值（包括小整数范围之外的值），请使用非小整数初始化此字段。这样，您就可以从一开始就获得正确的形态，并且可以避免迁移成本（和麻烦）。实现这一点的一个简单方法是在初始化时存储NaN，这也是React对问题的解决方法： 123456class Point { constructor(x, y) { this.x = NaN; this.x = x; this.y = NaN; this.y = y; }} 但也像所有性能建议一样：不要到处盲目地这样做。您的许多代码可能都是好的，不会受到性能的影响，即使对象有时会进行迁移。 你可以从本节得到的收获尽量避免混合不同类型的字段值，即不要混合数字、字符串、对象和其他原始值，除非您打算这样做。具体来说，不要将数字字段预初始化为null或undefined，而是选择合理的默认数字（如果有疑问，请使用NaN）。并尝试用小整数范围外的Double值来初始化Double值字段（也就是应该包含小整数范围外的数值的字段），也就是说，如果有疑问，首先在那里输入一个NaN，然后存储实际的初始值。 结论您应该相信 JavaScript 引擎通常会自动为您做正确的事。但与一切一样，了解一些细节是有好处的，所以万一遇到问题，你会找到解决的方法，有时如果启发式算法失败的话，给JavaScript引擎一个额外的提示可能是有益的。 附注 在撰写本文时，64位架构上的s是32位范围内的整数，但在不久的将来，这可能会改变为在future.Smi的任何地方都使用31位范围内的整数 尽管也有JavaScript虚拟机设法存储编码到值本身的短字符串，例如V7嵌入式JavaScript引擎就可以做到这一点。 这里的选择是完全武断的，这只是我会这么做的方式，因为它标志着我未来的自我阅读这些代码，我没有不小心的立即地覆盖该值，而是故意这样做的。您可以在这里使用任何非小整数，换言之，NaN 0.1 Number.MAX_VALUE -0可以全部在这里工作。 声明原文：JavaScript Performance Pitfalls in V8 翻译：SiYuanPub","link":"/2021/04/26/javascript-performance-pitfalls-v8/"}],"tags":[{"name":"async","slug":"async","link":"/tags/async/"},{"name":"prototype","slug":"prototype","link":"/tags/prototype/"},{"name":"v8 engine optimization","slug":"v8-engine-optimization","link":"/tags/v8-engine-optimization/"}],"categories":[{"name":"JavaScriptBasic","slug":"JavaScriptBasic","link":"/categories/JavaScriptBasic/"}]}